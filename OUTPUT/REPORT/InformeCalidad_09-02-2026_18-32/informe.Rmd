---
title: "Control de Calidad FASTQ"
date: "09-02-2026_18-32"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: flatly
---
```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE,
                      fig.width = 10, fig.height = 6)
library(ShortRead)
library(ggplot2)
library(dplyr)
library(knitr)

# Cargar resultados del qa()
datos_qa <- readRDS("datos_qa.rds")
```

# 1. Resumen General
```{r resumen}

read_counts <- datos_qa[["readCounts"]]
kable(read_counts, caption = "Número de reads por muestra")
```

# 2. Calidad media por Posición
```{r calidad_posicion}
# Extraer datos y calcular media ponderada para evitar el colapso del gráfico
qual_by_cycle <- datos_qa[["perCycle"]]$quality

qual_summary <- qual_by_cycle %>%
  group_by(lane, Cycle) %>%
  summarize(mean_score = weighted.mean(Score, Count), .groups = "drop")

ggplot(qual_summary, aes(x = Cycle, y = mean_score, color = lane)) +
  geom_line(linewidth = 1) +
  geom_hline(yintercept = 30, linetype = "dashed", color = "darkgreen") +
  geom_hline(yintercept = 20, linetype = "dashed", color = "orange") +
  facet_wrap(~lane, ncol = 2) +
  scale_y_continuous(limits = c(0, 42)) +
  theme_minimal() +
  labs(title = "Calidad Media por Ciclo",
       subtitle = "Media ponderada (Score x Count)",
       x = "Ciclo", y = "Phred Score Medio") +
  theme(legend.position = "none")
```

# 3. Composición de Bases
```{r bases}
base_by_cycle <- datos_qa[["perCycle"]]$baseCall

ggplot(base_by_cycle, aes(x = Cycle, y = Count, color = Base)) +
  geom_line(linewidth = 1) +
  facet_wrap(~lane, ncol = 2, scales = "free_y") +
  theme_minimal() +
  labs(title = "Composición de bases por ciclo",
       x = "Ciclo", y = "Frecuencia")
```

# 4. Distribución de Calidad
```{r dist_calidad}
# Distribución de calidad
qual_scores <- datos_qa[["perCycle"]]$quality

ggplot(qual_scores, aes(x = Score, fill = lane)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Distribución de scores de calidad",
       x = "Phred Score", y = "Densidad")
```

# 5. Frecuencia de Reads
```{r freq_reads}
# Frecuencia de reads (si está disponible)
if ("frequentSequences" %in% names(datos_qa)) {
  freq_seq <- datos_qa[["frequentSequences"]]
  kable(head(freq_seq, 10), caption = "Secuencias más frecuentes")
}
```

# 6. Conclusiones
```{r conclusiones}
# Calcular estadísticas generales
total_reads <- sum(read_counts$read)
avg_quality <- mean(qual_scores$Score, na.rm = TRUE)
```

- **Total de reads:** `r format(total_reads, big.mark = ",")`
- **Calidad media global:** `r round(avg_quality, 1)`
- **Número de muestras:** `r nrow(read_counts)`
```{r evaluacion, results="asis"}
if (avg_quality >= 30) {
  cat("\n✅ **Calidad excelente** - Puedes continuar con el análisis.\n")
} else if (avg_quality >= 20) {
  cat("\n⚠️ **Calidad aceptable** - Considera aplicar filtrado de calidad.\n")
} else {
  cat("\n❌ **Calidad baja** - Revisa el protocolo de secuenciación.\n")
}
```

---
*Generado el 09-02-2026_18-32*

